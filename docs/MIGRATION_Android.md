# Android AudioProModule.kt Migration to Turbo Modules

## Overview
The Android native module needs to be converted from `ReactContextBaseJavaModule` to support TurboModules while maintaining backward compatibility.

## Key Changes Required

### 1. Import Changes
**Add:**
```kotlin
import com.facebook.react.TurboReactPackage
import com.facebook.react.module.annotations.ReactModule
import com.facebook.react.turbomodule.core.interfaces.TurboModule
import com.facebook.react.bridge.Promise
import com.facebook.react.module.model.ReactModuleInfoProvider
```

### 2. Class Declaration Update
**Old:**
```kotlin
class AudioProModule(private val reactContext: ReactApplicationContext) :
    ReactContextBaseJavaModule(reactContext), LifecycleEventListener {
```

**New (Backward Compatible):**
```kotlin
@ReactModule(name = AudioProModule.NAME)
class AudioProModule(private val reactContext: ReactApplicationContext) :
    ReactContextBaseJavaModule(reactContext), 
    LifecycleEventListener,
    EventEmitterModule,
    AudioProModuleSpec {  // Generated by CodeGen
    
    companion object {
        const val NAME = "AudioPro"
    }
```

### 3. Implementation of EventEmitterModule Interface
**Add methods:**
```kotlin
override fun addListener(eventName: String) {
    // Required for RN EventEmitter
}

override fun removeListeners(count: Int) {
    // Required for RN EventEmitter
}
```

### 4. Update AudioProPackage.kt
**Old:**
```kotlin
class AudioProPackage : ReactPackage {
    override fun createNativeModules(reactContext: ReactApplicationContext): List<NativeModule> {
        return listOf(AudioProModule(reactContext))
    }
    
    override fun createViewManagers(reactContext: ReactApplicationContext): List<ViewManager<*, *>> {
        return emptyList()
    }
}
```

**New (Support Both Architectures):**
```kotlin
class AudioProPackage : TurboReactPackage() {
    override fun getModule(
        name: String,
        reactContext: ReactApplicationContext
    ): NativeModule? {
        return if (name == AudioProModule.NAME) {
            AudioProModule(reactContext)
        } else {
            null
        }
    }

    override fun getReactModuleInfoProvider(): ReactModuleInfoProvider {
        return ReactModuleInfoProvider {
            mapOf(
                AudioProModule.NAME to ReactModuleInfo(
                    _name = AudioProModule.NAME,
                    _className = "AudioProModule",
                    canOverrideExistingModule = true,
                    needsEagerInit = false,
                    isCxxModule = false,
                    isTurboModule = true
                )
            )
        }
    }
}
```

### 5. Gradle Plugin Configuration
**In `build.gradle`:**
```gradle
// Apply React Native CodeGen plugin
if (isNewArchitectureEnabled()) {
    apply plugin: "com.facebook.react"
}

// CodeGen configuration
react {
    jsRootDir = "../../src/"
    nodeExecutableAndArgs = ["node", "--max-old-space-size=4096"]
    codegenDir = "../../node_modules/react-native-codegen"
    libraryName = "AudioPro"
    codegenJavaPackageName = "dev.rnap.reactnativeaudiopro"
}
```

## Implementation Strategy

1. Update `AudioProModule.kt` to implement new interfaces
2. Update `AudioProPackage.kt` to support TurboReactPackage
3. Add CodeGen gradle configuration
4. Implement EventEmitterModule interface for event support
5. Maintain backward compatibility with old architecture

## Class Inheritance Diagram

```
New Architecture:
ReactContextBaseJavaModule + EventEmitterModule + AudioProModuleSpec -> TurboModule

Old Architecture:
ReactContextBaseJavaModule + LifecycleEventListener -> NativeModule
```

## Event Emission in New Architecture
The new architecture still uses the same event emission pattern:

```kotlin
private fun sendEvent(eventName: String, eventData: WritableMap) {
    val reactContext = reactContext
    reactContext.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter::class.java)
        .emit(eventName, eventData)
}
```

This remains consistent across both architectures.

## Build Flags
- `newArchEnabled` environment variable controls which architecture is built
- Both architectures coexist using conditional imports and interfaces

## Testing Approach

1. Build with `newArchEnabled=true` for new architecture
2. Build without flag for backward compatibility
3. Test all methods on both platforms
4. Verify events are emitted correctly

## References
- [RN Turbo Modules for Android](https://reactnative.dev/docs/the-new-architecture/turbo-modules-android)
- [TurboReactPackage Documentation](https://reactnative.dev/docs/the-new-architecture/backward-compatibility-turbomodules)
